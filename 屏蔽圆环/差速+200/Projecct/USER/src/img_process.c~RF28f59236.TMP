#include "img_process.h"

uint8 left_points[img_height];
uint8 right_points[img_height];
uint8 mid_points[img_height];
uint8 valid_row=img_height-1;
uint8 last_mid = 94;
uint8 global_threshold = 90,jump_threshold = 40;//全局阈值，跳变阈值
uint8 temp_row = 0;
uint8 left_lose, right_lose, all_lose;//左边丢线数量，右边丢线数量，两边同时丢线数量
//***************************************************边线处理****************************************************

////获取左右边界
//void Get_Edge_Related()
//{
//	//初始化
//	/*memset(left_points, 0, sizeof(left_points));
//	memset(mid_points, 94, sizeof(mid_points));
//	memset(right_points, 187, sizeof(right_points));*/
//	for(int i =0;i<ROW;i++)
//    {
//		left_points[i] = 0;
//		mid_points[i] = 94;
//		right_points[i] = 187;
//	}
//	left_lose = 0; right_lose = 0; all_lose = 0;
//	for (int i = img_height - 1; i >= 0; i--)
//    {
//		temp_row = img_height - i - 1;
//        //左线
//		for (int j = last_mid; j >= 1; j--)
//        {
//			if (j>=2&&image[i][j]>global_threshold&&image[i][j-1]<global_threshold&&image[i][j-2]<global_threshold)
//            {
//				left_points[temp_row] = j;break;
//			}
//			else if (j < 2 && image[i][j]>global_threshold&&image[i][j-1]<global_threshold)
//            {
//				left_points[temp_row] = j;break;
//			}
//		}
//		//右线
//		for (int j = last_mid; j <=186; j++)
//        {
//			if (j <= 185 &&image[i][j]>global_threshold&&image[i][j + 1]<global_threshold&&image[i][j + 2]<global_threshold)
//            {
//				right_points[temp_row] = j;break;
//			}
//			else if (j>185 && image[i][j]>global_threshold&&image[i][j + 1]<global_threshold)
//            {
//				right_points[temp_row] = j;break;
//			}
//		}
//		//丢线数量
//		if (left_points[temp_row] == 0&&right_points[temp_row]==187) all_lose++;
//		else if (left_points[temp_row] == 0) left_lose++;
//		else if (right_points[temp_row] == 187) right_lose++;
//		
//		//更新下一行中线位置
//		if (temp_row>0 && myabs( left_points[temp_row] - left_points[temp_row - 1]) > 10) left_points[temp_row] = left_points[temp_row - 1];// +(left_points[temp_row - 1] - left_points[0]) / temp_row;
//		if (temp_row>0 && myabs(right_points[temp_row] - right_points[temp_row - 1]) > 10) right_points[temp_row] = right_points[temp_row - 1];// +(left_points[temp_row - 1] - left_points[0]) / temp_row;
//		last_mid = (uint16)(left_points[temp_row] + right_points[temp_row]) / 2;
//		//判断是否结束这幅图的扫描
//		if (image[i-1][last_mid]<global_threshold&&image[i-1][last_mid-1]<global_threshold&&image[i-1][last_mid+1]<global_threshold)
//        {
//			if (Is_Black(i - 1) && Is_Black(i - 2)){
//				valid_row = temp_row + 1;//更新有效行数
//				last_mid = (left_points[10] + right_points[10])/2;//作为下幅图开始扫描的中点
//				break;
//			}
//		}       
//	}
//}

//定位灰度跳变位置
uint8 Search_Edge(uint8 Row_Index,uint8 Start,uint8 End)
{
    if(Start>End)
    {
        for(int i=Start;i>End;i--)
        {
            if(image[Row_Index][i]-image[Row_Index][i-1]>=Gray_Scale_Difference)
            {
                return i;
            }
        }
        return 0;
    }
    else
    {
        for(int i=Start;i<End;i++)
        {
            if(image[Row_Index][i]-image[Row_Index][i+1]>=Gray_Scale_Difference)
            {
                return i;
            }
        }
        return img_width-1;
    }
}

//获取左右边界
void Get_Edge_Related()
{
    uint8 last_middle=COL/2;
    for(int i=img_height-1;i>=0;i--)
    {
        //右边线
        right_points[i]=Search_Edge(i,last_middle,ROW-1);
        //左边线
        left_points[i]=Search_Edge(i,last_middle,0);
        last_middle=(left_points[i]+right_points[i])/2;
    }
}

//定位突变位置
Mutation_DefType Get_Edge_Mutation()       //返回突变位置
{
    Mutation_DefType mutation;
    mutation.Mutation_Num_Right=0;
    mutation.Mutation_Num_Left=0;
    uint8 found_start_right=0,found_start_left=0;
    for(int i=0;i<valid_row;i++)
    {
        //右边线突变
        if(right_points[i+1]-right_points[i]>Mutation_Judge_Pixels&&found_start_right==0)
        {
            mutation.Mutation_Start_Row_Right[mutation.Mutation_Num_Right]=i;
            found_start_right=1;
        }
        if(right_points[i]-right_points[i+1]>Mutation_Judge_Pixels&&found_start_right==1)
        {
            mutation.Mutation_End_Row_Right[mutation.Mutation_Num_Right]=i;
            mutation.Mutation_Num_Right++;
            found_start_right=0;
        }
        //左边线突变
        if(left_points[i]-left_points[i+1]>Mutation_Judge_Pixels&&found_start_left==0)
        {
            mutation.Mutation_Start_Row_left[mutation.Mutation_Num_Left]=i;
            found_start_left=1;
        }
        if(left_points[i+1]-left_points[i]>Mutation_Judge_Pixels&&found_start_left==1)
        {
            mutation.Mutation_End_Row_Left[mutation.Mutation_Num_Left]=i;
            mutation.Mutation_Num_Left++;
            found_start_left=0;
        }
    }
    return mutation;
}

//突变补线
void Fill_Line()
{
  Mutation_DefType mutation=Get_Edge_Mutation();
  uint8 x,y;
  //右边线补线
  for(int i=0;i<mutation.Mutation_Num_Right;i++)
  {
    y=mutation.Mutation_End_Row_Right[i]-mutation.Mutation_Start_Row_Right[i];
    x=abs(right_points[mutation.Mutation_End_Row_Right[i]]-right_points[mutation.Mutation_Start_Row_Right[i]]);
    for(int j=mutation.Mutation_Start_Row_Right[i];j<mutation.Mutation_End_Row_Right[i];j++)
    {
      right_points[j]=right_points[mutation.Mutation_Start_Row_Right[i]]-(j-mutation.Mutation_Start_Row_Right[i])*x/y;
    }
  }
  //左边线补线
  for(int i=0;i<mutation.Mutation_Num_Left;i++)
  {
    y=mutation.Mutation_End_Row_Left[i]-mutation.Mutation_Start_Row_left[i];
    x=abs(left_points[mutation.Mutation_End_Row_Left[i]]-left_points[mutation.Mutation_Start_Row_left[i]]);
    for(int j=mutation.Mutation_Start_Row_left[i];j<mutation.Mutation_End_Row_Left[i];j++)
    {
      left_points[j]=left_points[mutation.Mutation_Start_Row_left[i]]+(j-mutation.Mutation_Start_Row_left[i])*x/y;
    }
  }
}
//***************************************************边线处理****************************************************


//*************************************************判断指定行是否全黑****************************************************
uint8 Is_Black(uint8 row_index)
{
	uint8 white = 0;
	for (int i = 0; i < img_width; i++)
		if (image[row_index][i] > global_threshold)
			white++;
	return white < Fault_Tolerance ? 1 : 0;
}
//*************************************************判断指定行是否全黑****************************************************

//*************************************************计算角度误差****************************************************
//获取三点线性误差
float Get_Error()       //取有效区计算中点与边缘的差
{
    float k1,k2,k3;
    POINT a,b,c;
    if(valid_row<=Error_Caculate_Limit_Row)
    {
        a.x=0;
        a.y=(right_points[0]+left_points[0])/2;
        b.x=valid_row/2;
        b.y=(right_points[valid_row/2]+left_points[valid_row/2])/2;
        c.x=valid_row;
        c.y=(right_points[valid_row]+left_points[valid_row])/2;
    }
    else
    {
        a.x=0;
        a.y=(right_points[0]+left_points[0])/2;
        b.x=15;
        b.y=(right_points[15]+left_points[15])/2;
        c.x=30;
        c.y=(right_points[30]+left_points[30])/2;
    }
    k1=(c.x-b.x)/(c.y-b.y);
    k2=(b.x-a.x)/(b.y-a.y);
    k3=(c.x-a.x)/(c.y-a.y);
    return 10*k1+10*k2+10*k3;;
}

//获取两点间距离
float Get_Distance(POINT point1,POINT point2)
{
    return sqrtf(powf(point1.x-point2.x,2)+powf(point1.y-point2.y,2));
}

//计算曲率
float Caculate_Curvature()
{
    POINT a={(left_points[0]+right_points[0])/2,0};
    POINT b={(left_points[valid_row/2]+right_points[valid_row/2])/2,valid_row/2};
    POINT c={(left_points[valid_row]+right_points[valid_row])/2,valid_row};
    float ab,bc,ca;
    ab=Get_Distance(a,b);
    bc=Get_Distance(b,c);
    ca=Get_Distance(c,a);
    float cosA=(powf(ab,2)+powf(ca,2)-powf(bc,2))/(2*ab*ca);
    return bc/(sinf(acosf(cosA))*2);
}
//*************************************************计算角度误差****************************************************

//*************************************************元素判断****************************************************

TRACK_ELEMENT current_element;          //当前赛道元素

//刷新当前赛道元素
void Refresh_Current_Element()
{
    current_element=is_Start();   
    current_element=is_Barrier_or_Break();
}

//判断是否是‘十字’
TRACK_ELEMENT is_Cross()
{
    return CURVE;
}

//判断是否是‘起跑线’
TRACK_ELEMENT is_Start()
{
	return CURVE;
}

//判断是否是‘横断’或者‘断路’
//判断直道断路：某行全黑，判断弯道断路：白色三角
extern float direction_error;
TRACK_ELEMENT is_Barrier_or_Break()
{
    if(Is_Black(img_height-1)&&direction_error<1&&direction_error>-1)
    {
        //return BREAK;
    }
    if(right_points[valid_row-1]<img_width-3&&
       left_points[valid_row-1]>3&&
           right_points[valid_row-1]-left_points[valid_row-1]<10&&
               valid_row<40)
    {
        return BREAK;
    }
    return CURVE;
}

//判断是否是‘环岛’
TRACK_ELEMENT is_Roundabout()
{
    return CURVE;
}

//*************************************************元素判断****************************************************

